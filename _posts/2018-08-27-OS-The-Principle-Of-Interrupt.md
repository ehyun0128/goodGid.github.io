---
layout: post
title:  " 인터럽트의 원리 "
categories: OS
tags: OS
author: goodGid
---
* content
{:toc}


# 1. 컴퓨터 시스템의 구조

* 프로그램이 CPU에서 명령을 수행하려면 수행하려는 주소 영역이 메모리에 올라가 있어야 한다. <br> 이 때 프로그램의 주소 영역은 크게 <b>코드</b>,<b>데이터</b>,<b>스택 영역</b>으로 구분된다.

* 코드영역은 우리가 작성한 프로그램 함수들의 코드가 <b>기계어 명령</b>으로 변환되어 저장되는 부분이다.

* 데이터 영역은 전역 변수 등 프로그램이 사용하는 <b>데이터</b>를 저장하는 부분이다.

* 스택 영역은 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데 사용되는 공간이다.

* 일반적으로 프로그램 내에서 발생되는 함수 호출에 필요한 복귀 주소는 각 프로그램의 주소 공간 중 스택 영역에 보관한다.

* 반면, 인터럽트 때문에 CPU를 선점당한 위치를 저장하기 위한 공간은 OS 커널 부분에 존재하게 된다.

* OS는 현재 실행중인 모든 프로그램을 관리하기 위한 자료구조를 유지하고 있다. 

```
예를 들어 A,B 두 개의 프로그램이 현재 수행중이라면 
커널 어딘가에 이 두 프로그램을 관리하기 위한 자료 구조가 존재한다. 

이 자료 구조를 "프로세스 제어 블록(PCB)"라 부른다.
```

* [PCB](https://goodgid.github.io/OS-How-Computer-Systems-Work/#4-%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8-%ED%95%B8%EB%93%A4%EB%A7%81)에는 인터럽트가 발생했을 때 그 프로그램의 어느 부분까지 수행했는지를 저장하기 위한 영역이 존재한다.

```
프로그램 A가 수행중에 인터럽트가 발생하면
현재 실행중이던 지점을 A의 프로세스 제어 블록에 저장한 후,
인터럽트 처리 루틴으로 가서 인터럽트 발생관련 일 처리를 한다.

인터럽트 처리를 모두 마치면 
프로그램 A의 프로세스 제어 블록에 저장된 주소를 복원시켜 원래 수행하던 일을 재개하게 된다.
```

---

# 2. 컴퓨터 시스템의 작동 개요

* CPU를 컴퓨터의 두뇌라고 부르지만 <br> CPU는 인간의 뇌처럼 스스로 생각하고 판단하는 능력을 갖추고 있지는 못하다.<br> 이는 CPU가 빠른 속도로 처리하는 계산 능력은 가지고 있지만, <br> 어떠한 작업을 수행해야 하는지에 대해 스스로 결정하는 능력은 없기 때문이다.

* CPU는 현재 수행해야 할 <b>메모리 주소</b>의 명령을 있는 그대로 처리할 뿐이다. <br> 이 때, CPU가 수행해야 할 메모리 주소를 담고 있는 <b>레지스터</b>를 <b>프로그램 카운터</b>라고 부른다. <br> 즉, CPU는 매번 프로그램 카운터가 가리키는 메모리 영역의 명령을 처리하게 된다.

* 일반적으로 조건문, 반복문, 함수 호출 등에 의한 주소 이동이 없는 이상 프로그램 카운터는 <br> 바로 다음 주소의 명령을 가리키게 되어 코드의 <b>순차적인 수행</b>이 이루어진다.

<br>

* 메모리에는 사용자 프로그램 + OS 같이 올라가 수행된다. <br> 이 때 CPU는 프로그램 카운터가 가리키는 메모리 위치의 프로그램을 수행하게 된다.

```
if 프로그램 카운터가 메모리 주소 중 OS가 존재하는 부분을 가리킨다면 
    CPU가 커널 모드에서 수행중이라고 이야기한다.
else
    CPU가 사용자 모드에서 수행중이라고 이야기한다.
```

<br>

* CPU가 수행하는 명령에는 <b>일반 명령</b>과 <b>특권 명령</b>이 있다.

* 일반 명령은 메모리에서 자료를 읽어와서 CPU에서 계산하고 결과를 메모리에 쓰는 일련의 명령들을 말한다. <br> 이러한 일반 명령은 모든 프로그램이 수행할 수 있는 명령이다.

* 특권 명령은 <b>보안</b>이 필요한 명령으로 입출력 장치, 타이머 등 각종 <b>장치를 접근</b>하는 명령이다.

* 컴퓨터 시스템에서는 CPU내에 [모드 비트](https://goodgid.github.io/OS-How-Computer-Systems-Work/#%EC%BB%A4%EB%84%90-%EB%AA%A8%EB%93%9Ckernel-mode)를 두어 <b>특권 명령</b>을 항상 OS만이 수행할 수 있도록 제한하고 있다.

<br>

* 사용자 프로그램이 특권 명령의 수행이 필요한 경우 OS에게 특권 명령의 대행을 요청한다. <br> 이와 같은 서비스 요청을 <b>시스템 콜</b>이라고 한다.

* 사용자 프로그램이 시스템 콜을 하게 되면 OS는 자신의 커널 영역에 정의된 시스템 콜 처리 코드를 수행하게 된다.

* 프로그램이 아닌 주변 장치가 CPU에게 서비스를 요청할 때에도 시스템 콜과 비슷한 방식을 사용한다.

* CPU는 프로그램 카운터가 가리키는 메모리 위치의 명령만 계속 수행하기 때문에 <br> 주변 장치의 상태를 지속적으로 파악할 수 없다. <br> 따라서, 주변 장치는 CPU의 도움이 필요한 경우 인터럽트를 사용해 CPU에게 서비스를 요청하게 된다.

* 인터럽트를 발생시키기 위해 주변 장치는 <b>인터럽트 라인</b>을 세팅하고 <br> CPU는 매번 명령을 수행한 후 인터럽트 라인을 체크해 서비스 요청이 있는지 체크한다.

* 인터럽트가 발생하면 CPU는 해당 인터럽트를 처리하기 위한 루틴으로 넘어가서 커널 내의 인터럽트 처리 코드를 수행한다.

---

# 3. 

![](/assets/img/os/the_principle_of_interrupt_1.png)
![](/assets/img/os/the_principle_of_interrupt_2.png)
![](/assets/img/os/the_principle_of_interrupt_3.png)

---

# 4. 사용자 프로그램이 사용하는 함수

* 프로그램이 사용하는 함수는 크게 <b>사용자 정의 함수</b>와 <b>라이브러리 함수</b>, <b>커널 함수</b> 세 가지로 구분할 수 있다.

* 사용자 정의 함수란 프로그래머가 직접 작성한 함수를 뜻한다.

* 라이브러리 함수란 누군가가 작성해 놓은 함수를 호출만 하여 사용하는 경우를 뜻한다.

* 사용자 정의 함수와 라이브러리 함수는 모두 <b>컴파일</b>하여 실행 파일을 만들게 되면 <br> 프로그램의 코드 부분에 <b>기계어 명령</b> 형태로 삽입된다. <br> 따라서 이 두 함수는 프로그램이 실행될 때에 해당 프로세스의 주소 공간에 포함된다. <br> 또한, 함수 호출시에도 자신의 주소 공간에 있는 <b>스택</b>을 사용하게 된다.

* 한편 커널 함수는 OS 커널의 정의된 함수를 뜻한다.

* <b>커널 함수</b>의 종류에는 사용자 프로그램이 OS의 서비스를 요청하기 위한 <b>시스템 콜 함수</b>와 <br> HW / SW가 CPU의 서비스를 요청하기 위한 <b>인터럽트 처리 함수</b>가 있다.

* 이와 같은 커널 함수는 OS 커널의 주소 공간에 코드가 정의된다. <br> 즉, OS 있는 함수를 사용자 프로그램이 호출해서 사용하는 것이다.









