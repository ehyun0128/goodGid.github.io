---
layout: post
title:  "[BOJ] 15685. 드래곤 커브 "
categories: Algorithm
tags: BOJ reSolve
author: goodGid
---
* content
{:toc}

## Problem

Problem URL : **[치킨 배달](https://www.acmicpc.net/problem/15685)**












![](/assets/img/algorithm/15685_1.png)

![](/assets/img/algorithm/15685_2.png)

![](/assets/img/algorithm/15685_3.png)

![](/assets/img/algorithm/15685_4.png)


---

## [1] Answer Code (18. 10. 15)

``` cpp
#include<iostream>
#include<vector>
using namespace std;

/*
 다음과 같은 순서로 진행된다.
 →(0)  ↑(1)  ←(2)  ↓(3)
 > 모양이 끝점이라 생각하자.
 (st)---->(end) 이 모양에서 90도 회전하면
 끝점을 기준으로 회전이 이뤄지므로 (문제 조건)
 (end)점이 (st)점이 되고 ↓ 같은 모양을 갖게 된다.
 */
int dir[] = {0,1,2,3};

// 동 북 서 남
int dx[] = {0,-1,0,1};
int dy[] = {1,0,-1,0};

int map[101][101];

int n,m,d,g;

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);
    
    /*
     TC 2
     2 7 3 4를 보자
     다음과 같이 진행됨을 알 수 있다.
     0세대 남
     1세대 동
     2세대 북 [동](=1세대)
     3세대 북 서 [북 동](=2세대)
     4세대 북 서 남 서 [북 서 북 동](=3세대)
     */
    int tc;
    cin >> tc;
    for(int i=0; i<tc; i++){
        vector<int> v;
        cin >> m >> n >> d >> g;
        map[n][m] = 1;
        
        // 0세대
        n += dx[d];
        m += dy[d];
        map[n][m] = 1;
        
        // 1세대
        if( g > 0 ){
            n += dx[(d+1) % 4];
            m += dy[(d+1) % 4];
            map[n][m] = 1;
            v.push_back((d+1) % 4);
        }
        
        if( g > 1 ){
            for(int j=2; j<=g; j++){
                int size = (int) v.size();
                for(int k=0; k<size; k++){
                    /*
                     기존 vector에 insert되면
                     인덱스는 2배씩 점프한다.
                     [ 1 2 ]가 있는데
                     처음엔 1를 가리키기위해
                     0번째 인덱스를 참조하고
                     0이란 값이 insert가 되면
                     [ 0 1 2 ]가 된다.
                     여기서 2를 가리키기 위해선 2번째 인덱스를 참조해야한다.
                     */
                    int p = k * 2;
                    int idx = ( v[p] + 1 ) % 4;
                    /*
                     [ 2,7,3,4 ]라고 입력이 주어진다면
                     (실제로 들어오는 입력은 7,2,3,4 이지만 x,y 순서를 바꿨다.)
                     2,7에서 시작하여
                     방향은 3(=남)이고
                     세대는 4세대까지 진행되며
                     여기서 3,4세대의 진행 방향은 다음과 같다.
                     
                     3세대 북 서 [북 동](=2세대)
                     4세대 북 서 남 서 [북 서 북 동](=3세대)
                     
                     여기서 4세대를 반으로 나누어 관계를 찾아보면
                     (1) 북 서 남 서 / (2) 북 서 북 동
                     (2)의 '북'에서 한 방향 회전한 결과는 (1)의 마지막 값(=서)이다.
                     (2)의 '서'에서 한 방향 회전한 결과는 (1)의 세번째 값(=남)이다.
                     (2)의 '북'에서 한 방향 회전한 결과는 (1)의 두번째 값(=서)이다.
                     (2)의 '동'에서 한 방향 회전한 결과는 (1)의 세번째 값(=북)이다.
                     
                     그렇기 때문에 기존의 vector값(=이전 세대)에서
                     i 번째 인덱스 값을 회전 시킨 값을
                     vector에 처음에 insert를 해주게 되는 작업을 반복하면
                     최종적으로 원하는 순서대로 vector값을 갖게 된다.
                     */
                    v.insert(v.begin(), idx);
                } // end of for k
                
                /*
                 이전 세대 끝점을 기준으로
                 현재 vector에 들어있는 방향대로
                 방문 정점에 표시를 해준다.
                 */
                for(int k=0; k < size*2; k++){
                    n += dx[ v[k] ];
                    m += dy[ v[k] ];
                    map[n][m] = 1;
                } // end of for k
                
            } // end of for j
            
        } // end of if
    } // end of for i
    
    int ans = 0;
    for(int i=1; i<101; i++){
        for(int j=1; j<101; j++){
            /*
             네 꼭짓점이 모두 1이라면 드래곤 커브의 일부이다.
             */
            if( map[i][j] == 1 && map[i-1][j] == 1 &&
               map[i][j-1] == 1 && map[i-1][j-1] == 1
               ){
                ans ++;
            }
        } // end of for j
    } // end of for i
    
    cout << ans << endl;
    
    return 0;
}
```

### Review

* 삼성 역량 테스트 기출 문제

* 어렵다. 정답 코드 보고 1~2일 후에 다시 짰다.

* 자세한 설명은 코드에 주석으로 달아놨으니 다시 코드를 봐도 이해하는데 큰 어려움은 없을 거라 생각한다.

* 그런데 깔끔 명료한 코드를 찾아볼 필요가 있겠다. <br> <small>내 코드는 너무 ... 오케이 여기까지... </small>

