---
layout: post
title:  " Oracle Select SQL 튜닝 "
categories: Database
tags: Database
author: goodGid
---
* content
{:toc}

* 쿼리 튜닝은 **온라인 SQL**이냐 **대용량 배치 SQL**이냐에 따라 튜닝방법이 달라진다. 

* 하지만 대용량 배치는 프로그램 수가 많지 않은 편이다. 

* 온라인 SQL 튜닝에서도 관점에 따라 튜닝 방법이 다르게 된다. 

* 예를 들어 Peak Time에 Insert문 or Update문 or Select문이 집중적으로 몰릴 때의 튜닝 방법이 있고

* 단순히 **SQL 하나에 집중해서 응답시간을 최소화**하는 튜닝 방법이 있다. 

* 이 글은 일반적으로 가장 많은 튜닝 사례에 해당하는 Select문 튜닝 방법론을 기술한 포스팅이다.

* 학습 용도로 작성한 포스팅으로 본 포스팅의 원본 출처는 [Science of Database 블로그 SQL 튜닝방법](http://scidb.tistory.com/entry/SQL%ED%8A%9C%EB%8B%9D-%EB%B0%A9%EB%B2%95%EB%A1%A0)론 이다.











---

## 온라인 Select문 튜닝 방법론

* 온라인 SQL의 튜닝방법은 여러 가지가 있을 수 있다. 

* 하지만 그 중에서 가장 기초적이고, 기본적인 방법입다. 

* 아래의 7가지 항목을 점검하고 약한 곳을 보강하면 됩다. 

* 이글은 SQL 튜닝책을 두 권정도 본 사람들을 위한 것입다. 

* 튜닝에 자신있는 사람들은 볼 필요가 없다.


> [1] 적절한 인덱스를 사용하여 Block I/O를 최소화 하라

* 조인이 없는 경우는 적절한 인덱스를 사용하는 것만으로도 상당한 효과를 볼 수 있다. 

* 조인이 있는 경우는 특히 **Driving(선행) 집합**에 신경을 써야한다. 

* 왜냐하면 Nested Loop 조인을 사용했고 합의 건수가 많다면 

* 후행 집합의 조인의 시도 횟수가 증가하므로 성능이 느려지게 된다. 

* 따라서 적절한 인덱스를 이용하여 선행 집합의 건수를 줄이거나 가장 적은 집합을 선행으로 놓는다면

* 후행 집합으로의 조인 건수는 줄어들게 된다. 

* 물론 후행 집합의 적절한 인덱스는 필수 조건이다. 

* Driving 집합의 Block I/O를 줄이기 위하여 최적화된 인덱스가 없다면 생성하고 있다면 그것을 사용한다. 

* 다시 말해 **최적의 Access Path**를 만드는 것이 좋다.  

<br>

* 운영중인 시스템이라면 최적의 Access Path를 위해 인덱스를 변경하거나 생성할 때는 주의해야 한다. 

* 현재 튜닝하고 있는 SQL에 최적화된 인덱스를 생성하더라도 **다른 SQL에 악영향**을 줄 수 있기 때문이다. 

* 인덱스를 생성하거나 변경할 때는 그 테이블을 사용하는 다른 SQL의 실행 계획이 변경되지 않는지 각별히 신경써야 한다. 

* 이런 이유 때문에 개발 과정에서 효율적인 인덱스 설계가 중요시 된다.


---

> [2] 조인 방법과 조인 순서를 최적화 하라.

* 온라인에서 사용하는 Select문은 좁은 범위를 검색하는 경우가 많다. 

* 이런 경우 대부분 **Nested Loop Join**이 유리하다. 

* 그러므로 조인 건수가 소량인 SQL에 **Hash Join**이나 **Sort Merge Join**이 발견되면

* Nested Loop Join으로 변경하는 것이 더 유리한지 검토해야 한다. 

* 물론 여기서도 *Nested Loop 조인* 에 관해서만 다룬다.

<br>

* Nested Loop 조인에서 **가장 중요한 것은 조인 순서**이다. 

* From절에 **테이블(집합)이 두 개**라면

* 후행 집합의 관점에서는 적절한 인덱스만 존재한다면 그것으로 족합다. 

* 만약 From절에 **테이블(집합)이 세 개 이상**이라면 

* 조인 순서를 변경할 수 있는지에 대한 **두 가지 원리**를 사용하면 좋다. 

* 아무리 조인할 집합이 많다고 하더라도 이 두 가지의 원리는 동일하게 적용될 수 있다. 

* 두 가지 원리를 이용할 때 필요하다면 Leading 힌트를 사용해야 한다.

<br>

첫번째 방법 

* 후행 집합에 적절한 인덱스가 없는 경우에 **조인 순서**를 바꾸면 최적의 인덱스를 사용할 수 있는 경우가 많다. 

* 예를들어 튜닝전의 조인 순서가 A → B → C라고 하면 

* 중간 집합인 B에 적절한 인덱스가 없고 오히려 C에 적절한 인덱스가 존재하는 경우가 있다. 

* 이럴 때는 B에 인덱스를 무작정 생성하지 말고 

* 조인 순서를 A → C → B로 바꿀 수 있는지 바꾸는 것이 더 효율적인지 검증하면 좋다. 

* 조인 순서만 바꿔주어도 일량이 획기적으로 줄어드는 경우가 많다. 

* 만약 조인 순서를 바꿀 수 없거나 C를 중간 집합으로 하는 것이 비효율적이라면

* B를 중간 집합으로 유지하고 적절한 인덱스를 사용해야 한다.

<br>

두번째 방법

* 조인되는 집합 중 **특정 인덱스**에서 **Block I/O가 증가하는 경우**에 조인 순서의 변경을 검토하면 된다. 

* 이때 10046 Trace나 DBMS_XPLAN.Display_Corsor를 이용하면 조인 집합들의 Block I/O량을 관찰할 수 있다.

* 예를 들어 튜닝전에 조인 순서가 A → B → C라고 하고

* 집합 B에서 Block I/O량이 증가하면 A → C → B로 바꾸면 일량이 줄어드는 경우가 많다. 

* C를 먼저 **조인(Filter)**하여 선행 집합(B의 입장에서는 C가 선행이다)의 건수를 줄이고 B에 조인하면 성능이 향상된다.


---

> [3] Table Access(Random Access)를 최소화하라.

Random Access란 rowid로 테이블을 액세스하는 것을 말합니다. 1번과 2번을 최적화했다면 Random Access도 자동으로 많이 줄어들었을 것입니다. 하지만 그것이 끝은 아닙니다. 여전히 성능이 만족스럽지 못한다면 Random Access 횟수를 줄이는 것을 간과해서는 안됩니다.

<br>

인덱스를 사용하면 rowid가 자동으로 획득됩니다. 만약 인덱스에 없는 칼럼을 Select 해야 한다면 rowid로 테이블을 액세스 해야합니다. 이때 테이블로액세스해야 할 건수가 많고, 인덱스 컬럼순으로 테이블이 sort되어 있지 않다면 성능이 매우 저하됩니다. 왜냐하면 테이블이 인덱스 기준으로 sort되어 있지 않기 때문에 테이블을 방문할 때마다 서로 다른 블럭을 읽어야 하기 때문입니다.

<br>


비유적으로 설명해보겠습니다. 우리가 심부름을 할 때 세 군대의 상점(A, B, C)을 들러야 한다고 치겠습니다. 그 상점들이 모두 한 건물 내부에 존재한다면 얼마나 좋겠습니까? 그 심부름은 매우 빠른 시간에 끝날 것입니다. 하지만 반대로 상점 A는 부산에 있고 상점 B는 대구에 있고, 상점 C는 서울에 있다면? 만약 당신의 성격이 매우 좋아서 그 심부름을 한다고 해도 시간이 많이 걸릴 것입니다. Random Access도 마찬가지 입니다. 인덱스의 rowid로 테이블을 방문할 때 테이블이 인덱스기준으로 sort되어 상점처럼 다닥다닥 붙어있다면 성능은 매우 빠르고, 흩어져 있을수록 성능은 느려집니다. (오라클에서는 테이블이 인덱스 기준으로 sort되어 있는 정도를 Clustering Factor라고 합니다) 바로 이런 이유 때문에 index scan 보다는 Table Scan이 느린 것입니다. 따라서 우리는 Random Access의 부하를 최소화해야 합니다.

<br>


Random Access의 부하를 줄이는 방법은 네가지 입니다. 첫번째, 테이블의 종류를 변경하는 방법입니다. IOT나 클러스터를 이용하면 Clustering Factor가 극단적으로 좋아집니다. 또한 파티션을 이용하면 같은 범위의 데이터를 밀집시킬 수 있습니다. 두 번째, 효율적인 인덱스를 사용하거나 조인방법과 순서를 조정하여 Table Access를 최소화하는 방법입니다. 이 방법은 1번과 2번에서 이미 설명되었습니다. 세번째, 인덱스에 칼럼을 추가하여 Table Access를 방지하는 방법입니다. 예를 들어 Select절의 특정 칼럼 때문에 테이블이 액세스 된다면, 인덱스의 마지막에 그 컬럼을 추가하면 됩니다. 네 번째, 인덱스만 액세스하고 테이블로의 액세스는 모든 조인을 끝내고 마지막에 시도하여 Random Access의 횟수를 줄이는 방법입니다.












---

## 방법론 정리

1. 적절한 인덱스를 사용하여 Block I/O를 최소화하라.

2. 조인 방법과 조인 순서를 최적화 하라.

3. Table Access(Random Access)를 최소화하라.

4. Sort나 Gash 작업은 최소화하라.

5. 한 블록은 한번만 Scan하고 끝내라.

6. 온라인의 조회 화면이라면 페이징처리는 필수이다.

7. 답이 틀리면 안된다. SQL을 검증하라.

<br>

* 만약 1~7번을 **모두 적용**할 수 있는 경우임에도 불구하고 

* 하나라도 빠진다면 그것은 최적화된 SQL이 아닙다. 

* 물론 튜닝을 할때 위의 1~6번을 항상 적용할 수 있는 것은 아닙다. 

* 경우에 따라서는 하나만 적용될 수도 있고 두 개만 적용할 수 있는 SQL도 있다. 

* 하지만 1~6을 모두 적용할 수 있는지 꼼꼼히 살펴야 합다.


<br>

* 위 항목들은 튜닝의 **기본 중에 기본**이다. 

* 이것들만 알아도 온라인 조회 화면에 사용하는 SQL을 튜닝하는데 어려움이 없을 것이다. 

* 다시 말해 **90%는 해결**할 수 있다. 

* **나머지 10%**는 책이나 매뉴얼에 나와있지 않기 때문에 **경험 혹은 실험 연구의 결과**로 알아내야 한다.






---

## 참고

* [[Oracle] Select 쿼리 튜닝 순서](https://12bme.tistory.com/204)