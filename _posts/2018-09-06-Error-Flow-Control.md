---
layout: post
title:  " 흐름 / 혼잡 / 오류 제어 기법 "
categories: Technology
tags: Technology
author: goodGid
---
* content
{:toc}


## ToDo

* TCP의 가장 큰 특징은 신뢰성이다. <br> 이러한 신뢰성을 구성해 주는 방법인 **흐름제어**, **혼잡제어**, **오류제어**에 대해 알아보자.








---

## 흐름 제어

> 송신(호스트) <> 수신(호스트)

* 흐름제어는 수신측과 송신측의 데이터처리 속도차이를 해결하기 위한 기법이다.

* 만약 송신측의 전송량 > 수신측의 처리량 일 경우, 전송된 패킷은 수신측의 큐를 넘어서 <br> 손실될 수 있기 때문에 송신측의 패킷 전송량을 제어하게 된다.



---

## 흐름제어 방법


### 정지-대기(Stop-and-wait)

![](/assets/img/posts/error_flow_control_1.png)

* 구조가 간단한 대신, 하나를 주고 응답을 받기 때문에 비효율적이다.


### 슬라이딩 윈도우(Sliding Window)

* 윈도우는 전송,수신 스테이션 양쪽에서 만들어진 버퍼(Buffer)의 크기다. <br> 윈도우의 크기 = (가장 최근 ACK로 응답한 프레임의 수) - (이전에 ACK 프레임을 보낸 프레임의 수)

* 슬라이딩 윈도우 기법은 앞의 **정지-대기 기법**의 비효율성을 개선한 기법이다.

* ACK프레임을 수신하지 않더라도, 여러 개의 프레임을 연속적으로 전송할 수 있다.


* 전송측 윈도우 n-1 개의 프레임을 포함한다.

![](/assets/img/posts/error_flow_control_2.png)


* 위와 같은 구조에서 데이터 0, 1을 전송했다고 가정하면 <br> 슬라이딩 윈도우의 구조는 다음과 같이 변하며 윈도우의 크기는 전송한 데이터 프레임만큼 줄어들게 된다.


![](/assets/img/posts/error_flow_control_3.png)


* 이때 만약 수신측에서 ACK라는 프레임을 받게 된다면 전송측은 0, 1이 데이터를 정상적으로 받았음을 알게 되고, <br> 전송측은 ACK 프레임에 따른 프레임의 수만큼 오른쪽으로 경계가 확장된다.


![](/assets/img/posts/error_flow_control_4.png)





---



## 혼잡 제어

> 송신(호스트) <> 라우터(네트워크)


* 혼잡제어는 송신측과 네트워크의 데이터처리 속도 차이를 해결하기 위한 기법이다.

* 송신된 패킷이 네트워크 상의 라우터가 처리할 수 있는 양을 넘어서 혼잡하게 되면 <br> 데이터가 손실될 수 있기 때문에 송신측의 전송량을 제어하게 된다.


---

## 오류 제어

* **오류 제어 기법**은 **오류검출(error detection)**과 **재전송(retransmisstion)**을 포함한다.

* **ARQ(Automatic Repeat Request)**기법을 사용하여 프레임이 손상되었거나 손실되었을 경우 재전송을 통해 오류를 복구한다.

* ARQ기법은 흐름제어 기법과 관련되어있는데, <br> "정지-대기"는 정지-대기-ARQ로, <br> "슬라이딩 윈도우"는 GBn(Go-Back-n) ARQ 또는 SR(Selective-Reject) ARQ 형태로 구현한다.


---

## 오류 제어 종류 

> ARQ(Automatic Repeat Request) : 신뢰성 있는 데이터 전달을 위해 재전송을 기반으로 한 에러 제어 방식

### 정지-대기 ARQ

* 전송스테이션은 수신측에서 보내준 ACK를 받을 때 까지, 프레임의 복사본을 유지한다.

* 식별을 위해 데이터 프레임과 ACK프레임은 각각 0, 1번호를 부여한다.

* 수신측이 데이터를 받지 못했을 경우, NAK를 보내고, NAK를 받은 송신측은 데이터를 재전송한다.

* 만약 데이터나 ACK가 분실되었을 경우 일정간격의 시간을 두고 타임아웃이 되면, 송신측은 데이터를 재전송한다.

![](/assets/img/posts/error_flow_control_5.png)


---


### Go-Back-n ARQ (GBn ARQ)

* 전송된 프레임이 손상되거나 분실될 경우, 확인된 마지막 프레임 이후로 모두 재전송 하는 기법이다.

* 슬라이딩 윈도우는 연속적인 프레임 전송 기법이므로, <br> 전송 스테이션은 전송된 모든 프레임의 복사본을 가지고 있어야 하며, ACK와 NAK 모두 각각 구별을 해야한다.

* **ACK** : 다음 프레임을 전송 <br> **NAK** : 손상된 프레임 자체 번호를 반환

* 재전송 되는 경우는 다음과 같다.
    - [1] NAK 프레임을 받았을 경우
        - 만약, 수신측으로 0부터 5까지의 데이터를 보내었다고 가정한다.
        - 수신측에서 데이터를 받았음을 확인하는 ACK 프레임을 중간 중간 받게 되며, ACK 프레임을 확인한 전송측은 계속해서 데이터를 전송한다.
        - 그러나 만약 수신측에서 데이터 오류 프레임 2를 발견하고 NAK2를 전송 측에 보낸다.
        - NAK2를 받은 전송측은 데이터 프레임2가 잘못 되었다는 것을 알고 데이터를 재전송한다.
        - GBn ARQ의 특징은 바로 이 데이터를 재전송하는 부분이다.
        - GBn ARQ는 NAK(n)을 받아 데이터를 재전송하게 되면, n데이터만을 재전송하는 것이 아닌, n데이터 이후 데이터를 모두 재전송한다.

    - [2] 전송 데이터 프레임의 분실
        - GBn ARQ의 특징은 확인된 데이터 이후의 모든 데이터 재전송과 수신측의 폐기이다.
        - 수신측에서 데이터 1을 받았는데 갑자기 다음 데이터 3을 받게 된다면 <br> 수신측에서는 데이터 2를 못받았으므로 데이터 3을 폐기하고 NAK2를 전송측에 보낸다.
        - NAK를 받은 전송측은 위의 [1] 경우에서와 같이 NAK(n) 데이터부터 모두 재전송을 실시하며 <br> 수신측은 기존 받았던 데이터 중 NAK(n)으로 보내었던 대상 데이터 이후의 데이터를 모두 폐기하고 재전송 받는다.


    - [3] 지정된 타임아웃내의 ACK 프레임 분실(Lost ACK)
        - 전송스테이션은 분실된 ACK를 다루기 위해, 타이머를 가지고 있다. 
        - 전송측에서는 이 타이머의 타임아웃동안 ACK 데이터를 받지 못했을 경우, 마지막 ACK된 데이터부터 재전송한다.


![](/assets/img/posts/error_flow_control_6.png)


![](/assets/img/posts/error_flow_control_7.png)


* 전송측은 NAK 프레임을 받았을 경우, NAK 프레임 번호부터 다시 재전송을 시작한다.

* 수신측은 원하는 프레임이 아닐 경우 모두 폐기 처리한다.

* 타임아웃(ACK의 분실)일 경우,  마지막 ACK된 데이터부터 재전송한다.

---

### Selective-Reject(SR) ARQ

* GBn ARQ의 재전송되는 프레임 이후의 모든 프레임을 재전송하는 단점을 개선한 방법이다.

* SR ARQ는 손상된 분실된 프레임만 재전송한다.

* 그렇기 때문에 별도의 데이터 재정렬을 수행해야하며, **별도의 버퍼**를 **필요**로 한다.


---

## GBn ARQ 기법과 SR ARQ의 비교

![](/assets/img/posts/error_flow_control_8.png)


![](/assets/img/posts/error_flow_control_9.png)




---

## 참고

* [슬라이딩 윈도우, GBn & SR ARQ – 흐름 / 오류 제어 기법](http://wildpup.cafe24.com/archives/469#comments)

* [데이터링크의 흐름제어,혼잡제어,오류제어](http://lelumiere.tistory.com/11)