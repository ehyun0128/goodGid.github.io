---
layout: post
title:  " Python Study (1)  "
date:   2018-01-30
excerpt: "  Python Study (1) "
cate : "post"
tag:
- Python
---

## 18. 01. 30

## 유니코드

* 파이썬은 Default가 Unicode이다.

* 어떤 문자의 유니코드 값을 알고 싶거나 반대로 유니코드 값을 문자로 변환할 때

{% highlight python %}
>>> ord('s')
115

>>> chr(115)
's'

{% endhighlight %}

---

## 리스트

* 리스트는 값의 나열이다.

* 순서 존재, 여러 종류의 값을 담을 수 있다.

* 다음 예제와 같이 []로 묶어서 정의

* append, insert, extend, + ,index, pop, remove, reverse, sort 등 함수 사용 가능
{% highlight python %}
>>> colors = ['red', 'green', 'gold']
>>> colors
['red', 'green', 'gold']

>>> type(colors)
<class 'list'>

{% endhighlight %}

---

## 세트

* 수학시간에 배운 집합과 동일한 개념이다.

* 세트는 리스트와 마찬가지로 값의 모임 But 순서는 없다. 

* 다음 예제와 같이 {}로 묶어서 정의

{% highlight python %}
>>> a = {1,2,3}
>>> b = {3,4,5}

>>> a.union(b)
{1,2,3,4,5}
# a 세트값이 바뀌는건 아니다 ! 

>>> a.intersection(b)
{3}

{% endhighlight %}


--- 

## 튜플

* 리스트와 유사하지만 리스트와 달리 [] 대신 ()로 묶어서 표현

* 읽기 전용

* 읽기 전용인 만큼 제공되는 함수도 리스트에 비해 적지만, 속도는 그만큼 빠름


{% highlight python %}
>>> t = (1,2,3)
>>> type(t)
<class 'tuple'>
{% endhighlight %}

---


## 사전

* 키와 쌍으로 구성되어 있다.

{% highlight python %}
>>> d = dict(a=1, b=3, c=5)
>>> d
{'a': 1, 'b': 3, 'c': 5}
>>> type(d)
<class 'dict'>
{% endhighlight %}

* dict()생성자를 사용하지 않고 직접 사전을 생성할 수 있다

{% highlight python %}
>>> color = {"apple":"red", "banana":"yellow"}
>>> color
{'apple': 'red', 'banana': 'yellow'}
>>> color["apple"]
'red'
>>> color[0] # 인덱스는 지원 x 
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 0
{% endhighlight %}

* 새로운 값 추가하려면 새로운 키와 값을 할당하면 되고, 변경하는 법도 변경하려는 항목의 키에 변경할 값을 할당하면 된다.

{% highlight python %}
>>> color
{'apple': 'red', 'banana': 'yellow'}
>>> color["cherry"] = "red"
>>> color
{'apple': 'red', 'banana': 'yellow', 'cherry': 'red'}
>>> color["apple"] = "green"
>>> color
{'apple': 'green', 'banana': 'yellow', 'cherry': 'red'}
{% endhighlight %}



* 사전의 내용을 얻으려면 다음과 같이 items(), keys(), values()를 사용한다.

{% highlight python %}
>>> for c in color.items():
...     print(c)
... 
('apple', 'green')
('banana', 'yellow')
('cherry', 'red')

>>> for k in color.keys():
...     print(k)
... 
apple
banana
cherry

>>> for v in color.values():
...     print(v)
... 
green
yellow
red

>>> color
{'apple': 'green', 'banana': 'yellow', 'cherry': 'red'}
>>> del color['cherry']
>>> color
{'apple': 'green', 'banana': 'yellow'}
>>> color.clear()
>>> color
{}
{% endhighlight %}


---

* 얕은 복사와 깊은 복사

* 얕은 복사
    * a에는 [1,2,3]의 주소가 저장되어 있으므로 b에도 a와 동일한 주소가 복사된다. <br> 그러므로 a와b는 동일한 리스트 객체를 공유한다.
    
{% highlight python %}
>>> a = [1,2,3]
>>> b = a
>>> a[0] = 11
>>> a
[11, 2, 3]
>>> b
[11, 2, 3]

>>> id(a), id(b)
(4354094408, 4354094408)
{% endhighlight %}

* 깊은 복사
    * a와b가 같은 객체를 공유하지 않게 하려면 다음과 같이 강제로 복하면 된다.

{% highlight python %}
>>> a = [ 1,2,3 ]
>>> b = a[:]
>>> id(a), id(b)
(4354060168, 4354094856)
>>> a[0]=11
>>> a
[11, 2, 3]
>>> b
[1, 2, 3]
{% endhighlight %}

* 리스트의 경우 위와 같이 했지만 리스트 이외의 일반적인 경우에는 다음과 같이 <br> copy 모듈을 사용한다.

* copy() 함수는 주소가 복사되어 객체를 공유하는 `얕은 복사(Shallow Copy)`

* deepcopy() 객체를 공유하지 않는 `깊은 복사(Deep Copy)`


{% highlight python %}d
>>> import copy
>>> a = [1,2,3]
>>> b = copy.deepcopy(a)
>>> a[0]=11
>>> a
[11, 2, 3]
>>> b
[1, 2, 3]
{% endhighlight %}

---

## 함수

* 파이썬에서 함수 선언 방법은 다른 프로그램언어와 약간 다르다.

1. 함수 선언은 `def`로 시작해 `콜론(:)`으로 끝내고, 함수의 시작과 끝은 코드의 `들여쓰기(Indentation)`로 구분한다.

2. 시작과 끝을 명시해 주지 않는다.

3. 함수 선언을 헤더 파일에 미리 선언하거나 `인터페이스(Interface)` / `구현(Implementation)` 같은 부분으로 나누지 않고 함수가 필요할 때 바로 선언하고 사용할 수 있다.

```
def <함수명><인자1, 인자2, ... 인자N> :
    <구문>
    return <반환값>
```

* def는 함수 객체를 만들겠다는 키워드이다.

* 파이썬에서는 변수, 클래스는 물론 함수도 객체로 취급

* 파이썬에서는 블록의 개념을 `들여쓰기`로 사용하기 때문에 구문을 적을 때 반드시 들여쓰기를 해야한다.

* return 문이 없어도 함수 구문의 마지막에 다다르면 함수가 종료되고 이 때 함수는 None을 반환한다.

* return은 오직 1개의 객체만 반환할 수 있다. 하지만 다음 예제처럼 한 번의 함수 호출로 두 변수에 값을 각각 할당할 수도 있다.

* 정확히 말하자면 여러 개의 값을 반환하는 것이 아니라, 하나의 `튜플 객체`로 만들어 반환하는 것이다.

{% highlight python %}
>>> def swap(x,y):
...     return y,x
... 
>>> swap(1,2)
(2, 1)
>>> a, b = swap(1,2)
>>> a
2
>>> b
1
>>> x = swap(1,2)
>>> type(x)
<class 'tuple'>

{% endhighlight %}

---

## 인자 전달

* 호출자가 전달하는 변수가 변경 `가능한` 변수 / 변경 `불가능한` 변수일 때 내부에서 처리하는 방식이 다르다.

{% highlight python %}
>>> def change(x):
...     x[0] = 'H'   # list x의 첫 번째 아이템을 'H'로 바꾼다.
... 
>>> wordlist = ['J', 'A', 'M']
>>> change(wordlist)
>>> wordlist
['H', 'A', 'M'] # change가 호출자의 객체에게 영향을 미친다.
{% endhighlight %}

* `리스트`는 변경 가능한 변수 타입이기 때문에 위에 예와 같은 결과가 나타난다.

* 만약 함수 내부에서 변경해도 호출자의 객체에 영향을 미치지 않게 하려면 다음과 같이 복사해서 사용해야 한다.

{% highlight python %}
>>> def change(x):
...     x = x[:]     # 입력받은 인자를 모두 x에 복사한다.
...     x[0] = 'H'   # list x의 첫 번째 아이템을 'H'로 바꾼다.
...     return None
... 
>>> wordlist = ['J', 'A', 'M']
>>> change(wordlist)
>>> wordlist
['J', 'A', 'M'] # change가 호출자의 객체에게 영향을 미치지 않는다.
{% endhighlight %}


---

## 스코핑 룰

{% highlight python %}
>>> x = 1
>>> def func(a):
...     return a+x # 함수 내 지역 영역에 해당 이름이 없기 때문에 전역 영역에서 같은 이름을 찾아 사용한다.
... 
>>> func(1)
2
>>> def func2(a):
...     x=2 # 함수 내 지역 영역에 x라는 이름이 등록된다.
...     return a+x 
... 
>>> func2(1)
3
{% endhighlight %}

* 이처럼 이름을 검색하는 규칙이 있는데, 이름을 사용하면 `지역(Local)`, `전역(Global)`, `내장(Built-in)`인 순서로 검색한다.

* 이 규칙을 첫 글자를 따서 `LGB 규칙`이라고 한다.

* 만약 지역 영역에서 전역 영역의 변수를 사용하고 싶을 땐 `global` 선언물을 사용하면 된다.

{% highlight python %}
>>> g = 1
>>> def Scope(a):
...     global g
...     g = 2
...     return g+a
... 
>>> Scope(1)
3
>>> g
2
>>
{% endhighlight %}

* 전역 영역에 변수 g가 없을 경우 global g라는 Line에서 에러가 발생한다.

---

## 함수 인자

1. 기본 인자 값
2. 키워드 인자
3. 가변 인자 리스트
4. 정의되지 않은 인자 처리하기


### 키워드 인자 
* 인자 이름으로 값을 전달하는 방식이다.

* 변수의 전달 순서를 맞춰 전달 + 명시적 키워드 인자 사용

{% highlight python %}
>>> def connectURI(server,port):
...     str = "http://" + server + ":" + port
...     return str
... 

>>> connectURI("test.com","8080")
'http://test.com:8080'

>>> connectURI(port="8080",server="test.com") # 명시적으로 인자 이름을 사용
'http://test.com:8080'

>>> connectURI("test.com",port="8080") # 키워드 인자 이후에는 순서에 의한 인자 매칭을 시도
'http://test.com:8080'

>>> connectURI(server="test.com","8080")
  File "<stdin>", line 1
SyntaxError: positional argument follows keyword argument
{% endhighlight %}

* 기본 인자 값과 마찬가지로 일반적으로 `키워드 인자`는 `일반 인자` 뒤에 위치한다.

* `키워드 인자` 이후에는 `순서에 의한 인자 매칭`을 할 수 없다.


---

### 가변 인자 리스트

{% highlight python %}

{% endhighlight %}

{% highlight python %}

{% endhighlight %}



















